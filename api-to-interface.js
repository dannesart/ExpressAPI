const fs = require("fs");
const path = require("path");
const prettier = require("prettier");
const fetch = require("node-fetch");
require("dotenv").config();

let documentationID = "60d491a60fd45b00010a9c8a";
let url = `https://api.io.cash/portal/apis/${documentationID}/documentation/raw`;
let fileName = "IOCashAPI";
let libName = "";
let outputDirPath = "./services/payment";
let options = {
  method: "GET",
};
let allTags = {};

function createFile(content) {
  const fileContent = prettier.format(content.join("\n \n"), {
    parser: "typescript",
  });
  const dirPath = libName
    ? path.resolve(__dirname, `../libs/${libName}/src/lib/interfaces/API`)
    : path.resolve(__dirname, outputDirPath);
  fs.mkdirSync(dirPath, { recursive: true });
  const pathToFile = path.resolve(
    dirPath,
    `${fileName || "AutoGeneratedInterfaces"}.ts`
  );
  fs.writeFileSync(pathToFile, fileContent, "utf-8");
}

function translateType(type) {
  if (!type) {
    return type;
  }
  switch (type) {
    case "integer":
      return "number";
      break;
    case "string":
      return "string";
      break;
    case "number":
      return "number";
      break;
    case "boolean":
      return "boolean";
      break;
    case "object":
      return "object";
      break;
    default:
      return type.indexOf("I") === 0 ? type : toInterfaceName(type);
      break;
  }
}

function generateUrlMethod(operationId, methodType, endpoint) {
  const routeIds = endpoint.split("/").filter((id) => id.indexOf("{") > -1);
  const cleanIds = routeIds.map((id) => id.replace(/[{,}]/g, ""));
  const templateUrl = "`" + endpoint.replace(/{/g, "${") + "`;";
  return `export function ${operationId}_URL(${cleanIds.join(
    ","
  )}){ return ${templateUrl} }`;
}

function toInterface(operationId, params, methodType, summary, deprecated) {
  operationId = operationId.substr(0, 1).toUpperCase() + operationId.substr(1);
  const headersHeader = `/** 
                    * ${summary} (Headers) ${
    deprecated ? "\n * @deprecated" : ""
  } 
                    */`;
  const bodyHeader = `/** 
                    * ${summary} (Body) ${deprecated ? "\n * @deprecated" : ""} 
                    */`;
  const headersNodes = [];
  const bodyNodes = [];

  const headerInterface = [
    headersHeader,
    `export interface I${operationId}_HEADERS {`,
  ];
  const bodyInterface = [bodyHeader, `export interface I${operationId}_BODY {`];

  if (params && params.length) {
    for (let i = 0; i < params.length; i++) {
      const param = params[i];

      if (param.schema && param.schema.$ref) {
        param.type = toInterfaceName(
          param.schema.$ref.substr(param.schema.$ref.lastIndexOf("/") + 1)
        );
      }
      const nodeRequired = param.required ? "" : "?";
      const interfaceNode = `${param.name.replace(
        /[\., ]/g,
        ""
      )}${nodeRequired}: ${translateType(param.type)} // Added in ${param.in}`;
      if (param.in === "header") {
        headersNodes.push(interfaceNode);
      } else if (param.in === "body") {
        bodyNodes.push(interfaceNode);
      }
    }
    headerInterface.push(headersNodes.join(",\n"));
    bodyInterface.push(bodyNodes.join(",\n"));
  }
  headerInterface.push(" }");
  bodyInterface.push(" }");
  return [headerInterface.join("\n"), bodyInterface.join("\n")].join("\n");
}

function loopParams(params) {
  for (let i = 0; i < params.length; i++) {
    const param = params[i];
    if (params.schema && params.schema.$ref) {
      params[i] = param;
    }
  }
  return params;
}

function loopProps(properties) {
  const nodes = [];
  Object.keys(properties).forEach((propertyId) => {
    const prop = properties[propertyId];
    if (prop) {
      let { items, type, format } = prop;
      if (propertyId.indexOf("_") === -1) {
        type = translateType(type);
        if (items) {
          if (items.$ref) {
            items.type = translateType(
              items.$ref.substr(items.$ref.lastIndexOf("/") + 1)
            );
          }
          type = `${items.type}[]`;
        }
        const node = `${propertyId.replace(
          /[\., ]/g,
          ""
        )}: ${type} // Format: ${format}`;
        nodes.push(node);
      }
    }
  });
  return nodes.join(", \n");
}

function toInterfaceName(name) {
  return name ? "I" + name.substr(0, 1).toUpperCase() + name.substr(1) : name;
}

function buildDefinitions(_definitions) {
  const defininitions = [];

  Object.keys(_definitions).forEach((definitionId) => {
    if (definitionId.indexOf("Â«") === -1) {
      const defininition = [
        `export interface ${toInterfaceName(definitionId)} {`,
      ];
      const { properties, type } = _definitions[definitionId];
      if (properties) {
        const props = loopProps(properties);
        defininition.push(props);
      }
      defininition.push("}");
      defininitions.push(defininition.join("\n"));
    }
  });

  return defininitions.join("\n \n");
}

fetch(url, options)
  .then((res) => res.json())
  .then((swagger) => {
    // Host = https://api.io.cash/....
    const { paths, host, tags, definitions } = swagger;

    // Content
    let content = [`export namespace ${fileName} {`];

    // Add host
    content.push(`export const host = '${host}'; \n `);

    // Add definitions
    content.push(`/**
    * @Definitions
    */`);
    content.push(buildDefinitions(definitions));

    // Loop thru tags, and add them to the object.
    tags.forEach((tag) => (allTags[tag.name] = tag));

    content.push(`/**
    * @Interfaces and @Endpoints
    */`);

    // Loop thru endoints
    Object.keys(paths).forEach((endpoint) => {
      // Endpoint = /xxxxx/yyy/zzz
      // Methods = { get: ..., post: ... }
      const methods = paths[endpoint];

      Object.keys(methods).forEach((methodType) => {
        // methodType = GET, POST, DELETE...
        // Method = { tags:..., parameters:... }
        const { tags, parameters, operationId, summary, deprecated } =
          methods[methodType];
        // OperationID = ID for that excact operation. ex. "extraWalletUsingPOST"
        const interface = toInterface(
          operationId,
          loopParams(parameters),
          methodType,
          summary,
          deprecated
        );

        // Url method
        const urlMethod = generateUrlMethod(operationId, methodType, endpoint);

        // Push interface to namespace.
        content.push(interface);
        content.push(urlMethod);
      });
    });
    content.push("}");
    console.log("** IO.CASH");
    //console.log(swagger);
    createFile(content);
  })
  .catch((err) => {
    console.log(err);
  });
